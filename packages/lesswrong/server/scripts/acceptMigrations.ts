import { readFile, readdir, writeFile } from "node:fs/promises";
import path from "path";

const ROOT_PATH = path.join(__dirname, "../../../");
const schemaChangelogPath = (rootPath: string) => path.join(rootPath, "schema/schema_changelog.json");
export const migrationsPath = (rootPath: string) => path.join(rootPath, "packages/lesswrong/server/migrations");

export interface SchemaChangelogEntry {
  acceptsSchemaHash: string;
  acceptedByMigration?: string;
  timestamp: string;
}

export const migrationNameToDate = (name: string): Date => {
  const s = name.split(".")[0];
  if (s.length !== 15 || s[8] !== "T") {
    throw new Error(`Invalid migration name: '${s}'`);
  }
  if (name.match(/^.*\.auto\.ts$/)) {
    throw new Error(`You must rename the migration from 'auto' to something more recognizable: ${name}`);
  }
  const stamp = `${s.slice(0, 4)}-${s.slice(4, 6)}-${s.slice(6, 11)}:${s.slice(11, 13)}:${s.slice(13, 15)}.000Z`;
  return new Date(stamp);
};

export const migrationNameToTime = (name: string): number => {
  return migrationNameToDate(name).getTime();
};

const assertNoDuplicateTimestamps = (entries: SchemaChangelogEntry[]) => {
  const timestamps = entries.map((e) => e.timestamp);
  const uniqueTimestamps = new Set(timestamps);
  if (timestamps.length !== uniqueTimestamps.size) {
    throw new Error(`Duplicate timestamps: ${timestamps.sort()}`);
  }
};

const getSchemaChangelogEntries = async (rootPath: string): Promise<SchemaChangelogEntry[]> => {
  const schemaChangelog = await readFile(schemaChangelogPath(rootPath), "utf8");
  return JSON.parse(schemaChangelog);
};

const getMigrationChangelogEntries = async (rootPath: string): Promise<SchemaChangelogEntry[]> => {
  const migrationFiles = (await readdir(migrationsPath(rootPath), { withFileTypes: true }))
    .filter((dirent) => dirent.isFile())
    .map((dirent) => path.join(migrationsPath(rootPath), dirent.name));

  const migrationChangelogEntries: SchemaChangelogEntry[] = [];
  for (const migrationFile of migrationFiles) {
    // NOTE: I'm using this regex hack rather than importing because esbuild doesn't support
    // dynamic imports, I would very much like to change this
    const acceptsHashRegex = new RegExp(/^export const acceptsSchemaHash = ["'](.*)["']/);
    const contents = (await readFile(migrationFile)).toString().split("\n");
    const acceptsHashLine = contents.find((line) => acceptsHashRegex.test(line));

    if (!acceptsHashLine) continue;

    const match = acceptsHashRegex.exec(acceptsHashLine);

    if (!match) throw new Error(`Invalid acceptsHashLine: ${acceptsHashLine}`);

    const acceptsHash = match[1];
    const migrationName = path.basename(migrationFile);
    const timestamp = migrationNameToDate(migrationName);

    migrationChangelogEntries.push({
      acceptsSchemaHash: acceptsHash,
      acceptedByMigration: migrationName,
      timestamp: timestamp.toISOString(),
    });
  }

  return migrationChangelogEntries;
};

const arrayToTimestampMap = (array: SchemaChangelogEntry[]): Record<string, SchemaChangelogEntry> => {
  const map: Record<string, SchemaChangelogEntry> = {};
  for (const entry of array) {
    map[entry.timestamp] = entry;
  }
  return map;
};

/**
 * There are two ways you can "accept" a schema change, by adding a migration file with `export const acceptsSchemaHash = "..."`,
 * or by manually editing schema_changelog.json. This function merges changes accepted by migrations into schema_changelog.json. In doing this, we want to:
 * - Preserve manually added entries in schema_changelog.json (i.e. entries without acceptedByMigration)
 * - Assert that all the acceptedByMigration files still exist
 */
const updateSchemaChangelogWithMigrationEntries = async ({
  schemaChangelogEntries,
  migrationChangelogEntries,
}: {
  schemaChangelogEntries: SchemaChangelogEntry[];
  migrationChangelogEntries: SchemaChangelogEntry[];
}) => {
  assertNoDuplicateTimestamps(schemaChangelogEntries);
  assertNoDuplicateTimestamps(migrationChangelogEntries);

  const schemaChangelogEntriesMap = arrayToTimestampMap(schemaChangelogEntries);
  const migrationChangelogEntriesMap = arrayToTimestampMap(migrationChangelogEntries);

  const newSchemaChangelogEntries: SchemaChangelogEntry[] = [];

  for (const timestamp in migrationChangelogEntriesMap) {
    if (schemaChangelogEntriesMap[timestamp]) {
      const existingEntry = schemaChangelogEntriesMap[timestamp];
      const newEntry = migrationChangelogEntriesMap[timestamp];
      if (
        existingEntry.acceptsSchemaHash !== newEntry.acceptsSchemaHash ||
        existingEntry.acceptedByMigration !== newEntry.acceptedByMigration
      ) {
        const existingString = JSON.stringify(existingEntry);
        const newString = JSON.stringify(newEntry);
        throw new Error(
          `Cannot change accepted migration: ${timestamp}. The entry in schema_changelog.json is ${existingString}` +
            ` but the entry generated by the migration file is ${newString}`,
        );
      }
    } else {
      // eslint-disable-next-line no-console
      console.log("Adding new entry to schema_changelog.json:\n", migrationChangelogEntriesMap[timestamp]);
    }
    newSchemaChangelogEntries.push(migrationChangelogEntriesMap[timestamp]);
  }

  const manualEntries = schemaChangelogEntries.filter((entry) => !migrationChangelogEntriesMap[entry.timestamp]);

  // Assert that the manual entries are in fact manual, if they have an acceptedByMigration field this
  // probably means that the migration file was deleted
  const invalidManualEntries = manualEntries.filter((entry) => entry.acceptedByMigration);
  if (invalidManualEntries.length) {
    // eslint-disable-next-line no-console
    console.error(
      `There are entries with an acceptedByMigration field in schema_changelog.json where the corresponding migration can't be found. ` +
        `This is probably because the migration files were deleted. If you really do want to delete these files then remove these entries from schema_changelog.json:`,
      invalidManualEntries,
    );
    throw new Error();
  }

  newSchemaChangelogEntries.push(...manualEntries);
  return newSchemaChangelogEntries.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
};

export const acceptMigrations = async ({
  write = true,
  rootPath = ROOT_PATH,
}: {
  write: boolean;
  rootPath: string;
}): Promise<SchemaChangelogEntry> => {
  const schemaChangelogEntries = await getSchemaChangelogEntries(rootPath);
  const migrationChangelogEntries = await getMigrationChangelogEntries(rootPath);

  const newSchemaChangelogEntries = await updateSchemaChangelogWithMigrationEntries({
    schemaChangelogEntries,
    migrationChangelogEntries,
  });

  if (write) {
    await writeFile(schemaChangelogPath(rootPath), JSON.stringify(newSchemaChangelogEntries, null, 2));
  } else {
    if (JSON.stringify(newSchemaChangelogEntries) !== JSON.stringify(schemaChangelogEntries)) {
      throw new Error(`schema_changelog.json is out of date. Run 'yarn acceptmigrations' to update it.`);
    }
  }

  return newSchemaChangelogEntries[newSchemaChangelogEntries.length - 1];
};
